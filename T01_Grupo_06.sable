Helpers
 tudo = [0 .. 0xFFFF];
 digito = ['0' .. '9'];
 digito_bin = '0' | '1';
 binario = '0b' digito_bin+;
 letra = ['a' .. 'z'] | ['A' .. 'Z'];
 espaco = ' ';
 underscore = '_';
 rc = 13;
 nl = 10;
 eol = rc nl | rc | nl;
 senao = 'senao';
 tudo_menos_rc = [tudo - rc];
 tudo_menos_rc_nl = [tudo - [rc + nl]];
 
 coment_linha = '--' tudo_menos_rc_nl* eol; 
 coment_bloco = '{' [tudo - '}']* '}';
 comentario = coment_linha | coment_bloco;

 vazio = (espaco | rc | nl)+;
 
Tokens
 numero = ('-'?digito+) | binario;
 decimal = digito+ ',' digito+;
 
 // OPERADORES E SIMBOLOS
 ponto_virgula = ';';
 col_esq = '[';
 col_dir = ']';
 par_esq = '(';
 par_dir = ')';
 soma = '+';
 menos = '-';
 mult = '*';
 div = '/';
 mod = '%';
 maior_q = '>';
 maior_igual = '>=';
 igual = '=';
 e = 'e';
 ou = 'ou';
 nao = 'nao';
 separador = '|';
 dois_pontos = ':';
 atribuicao = '<<';
 proced_principal = '>>';

 // PALAVRAS RESERVADAS
 var = 'var';
 const = 'const';
 tipo_inteiro = 'inteiro';
 tipo_real = 'real';
 tipo_booleano = 'booleano';
 tipo_cadeia = 'cadeia';
 ini_bloco = 'comece';
 fim_bloco = 'termine';
 enquanto = 'enquanto';
 se = 'se';
 senao = 'senao';
 verdadeiro = 'verdadeiro';
 falso = 'falso';
 funcao = 'funcao';
 procedimento = 'procedimento';
 
 tipo_array = 'inteiro' | 'real' | 'booleano' | 'cadeia' ( '[' (digito+ | binario) ']' )+;
 
 id = (letra | underscore | 'size' | 'imprima' | 'leia')(letra | underscore | digito)*;

 cadeia = ''' ([tudo_menos_rc - '''])+ ''';
 
 vazio = vazio;
 comentario = comentario;
 
Ignored Tokens
 vazio,
 comentario;
 
 
 Productions

// Estou dizendo que irá comecar um programa seguido
// de declaracoes e expressoes

 programa = decs_var_const* decs_proc_func+;
 
 decs_var_const = 
   {dec_var} dec_var
  |{dec_cons} dec_cons;
  
  decs_proc_func =
   {dec_procedimento} dec_procedimento
  |{dec_funcao} dec_funcao;
 
 dec_cons = const dois_pontos tipo id_atribuicao ponto_virgula;
 
 // var : <tipo> << <valor>; DÚVIDA: Pode duas atribuições na mesma linha?
 
 dec_var =  var dois_pontos tipo ids ponto_virgula;
 
 ids = 
 	{id} id 
 	| {id_atribuicao} id_atribuicao;
 
 tipo = 
  {tipo_base} tipo_base 
 |{tipo_arr} tipo_base col_esq exp col_dir;
 
 tipo_base = 
  {tipo_inteiro} tipo_inteiro 
 |{tipo_booleano} tipo_booleano 
 |{tipo_real} tipo_real 
 |{tipo_cadeia} tipo_cadeia;
 
  id_atribuicao = id atribuicao exp;
  
  // Dúvida: O que é isso?
  array_comp = col_esq id_exp col_dir;
  
  // dec_procedimento: ('>>')? 'procedimento' ':' ID '(' parametros ')' comando
  dec_procedimento = proced_principal? procedimento dois_pontos id par_esq  parametros par_dir; //nao finalizado
  dec_funcao = funcao dois_pontos tipo id par_esq parametros par_dir exp;
  
  parametros = separador_parametro_vazio;
  
  separador_parametro_vazio = 
  	{parametro_separador_parametro} parametro_separador_parametro
  	| {vazio} ;
  
  parametro_separador_parametro = parametro separador_parametro*;
  
  separador_parametro = separador parametro;
  
  parametro = tipo_parametro id;
  
  // Dúvida: o nome {} deve ser repetido com o que vem
  tipo_parametro = 
  	 {tipo_base} tipo_base
  	|{tipo_parametro} tipo_parametro col_esq col_dir;
  
  // Dúvida: Quando que eu vou trocar os nomes do inicio {}
  // O que acontece nesse caso?
  //array_comp 	= col_esq id_exp col_dir;
  //		= [ id_exp col_dir
  //		= [ exp col_dir
  //		= [ exp soma fator col_dir
  id_exp = 
  	 {id} id
  	|{exp} exp;
  
  valor = 
   {id} id 
  |{valor} valor col_esq exp col_dir;
  
// bloco_comandos = ini_bloco dec_var_const* comando* fim_bloco;
  chamada_funcao = id par_esq lista_exp par_dir;
  
  chamada_procedimento = id par_esq lista_exp par_dir;
  
  lista_exp = 
  	{exp_ini} exp separador_exp*
  	|{vazio} ;
  
  separador_exp = separador exp;
  
  bloco_expressoes = ini_bloco dec_cons* exp fim_bloco;
  
  comando_mae = 
      {comando_se} comando_se
      | {tudo_menos_se} tudo_menos_se;
  
  comando_se = 
    {casam_decl1} casam_decl
    | {sem_casam_decl1} sem_casam_decl
    | {outra} tudo_menos_se;
  
  sem_casam_decl = 
  	{sem_casam_decl1} se par_esq exp par_dir comando_mae
  	|{sem_casam_decl2} se par_esq exp par_dir casam_decl senao sem_casam_decl;
  	
  casam_decl = 
    {casa_decl1} se par_esq exp par_dir casa_decl1 senao casa_decl1
    | {casa_decl2} tudo_menos_se;
  
  tudo_menos_se = 
  	{outra1} enquanto par_esq exp par_dir comando_mae
  	|{outra2} id_atribuicao ponto_virgula
  	|{outra3} chamada_procedimento ponto_virgula
  	|{outra4} bloco_comandos;
  
  exp =
   {fator} fator 
  |{soma} exp soma fator 
  |{menos} exp menos fator;
  
 fator =
   {termo} termo 
  |{mult} fator mult termo 
  |{div} fator div termo 
  |{mod} fator mod termo;
 
 termo =
   {numero} numero 
  |{exp} par_esq exp par_dir;
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 